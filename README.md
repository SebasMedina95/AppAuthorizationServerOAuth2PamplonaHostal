# AUTHORIZATION SERVER

<div style="text-align: center;">
  <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/79/Spring_Boot.svg/640px-Spring_Boot.svg.png" alt="Spring Boot Logo" width="150"/>
</div>

### Desarrollado por: ###
Desarrollador del Sistema: [Juan Sebastian Medina Toro](https://www.linkedin.com/in/juan-sebastian-medina-toro-887491249/)

Esta aplicación tiene como finalidad generar todo lo necesario para
el desarrollo con OAuth2 para el aplicativo que estamos haciendo para
el Hotel Pamplona. La idea es que estaremos conectando el tema de 
usuarios a este punto para el acceso a las credenciales así como los
accesos iniciales.

En este punto estaremos también trabajando con la conexión hacía Docker,
pero, la que hicimos en la API, por lo que solo traemos los elementos 
necesarios de perfil para la comunicación.

### Información de utilidad:
* Para la prueba de apertura del Login para generar el Authorization Code
hemos usado el sitio: ``https://oauthdebugger.com/``. Hemos proporcionado
los siguientes datos en los campos:
    * Authorize URI (required) = http://localhost:9776/authorization-server/oauth2/authorize
    * Redirect URI (required) = https://oauthdebugger.com/debug
    * Client ID (required) = client-pamplona
    * Scope (required) = openid ALL
    * State (autogenerated) = jft5wwudwd
    * Nonce (autogenerated) = 70on2e0mnqg
    * Response type (required) = code
    * Response mode (required) = form_post

En este caso, el Client ID que lo tenemos como client obedece a un registro de base de datos que tenemos como client
y lo que tenemos como Scope obedece a los accesos que se están dando a nivel de cliente.

Nos abrirá un link que se ve así: http://localhost:9776/authorization-server/login
En este link ingresamos las credenciales (``Es un Basic Auth``)
La idea es que se nos generará un código que se ve así:
````dockerfile
FGvXMKaD83122Kzb6wA30-arU_zTXmksU3b5543zNFq-KzhIeITWfrcFOeyLuUGlgiG_537T4LzWLZsSN_jRzeKTER1liq77-_5cwmCH4pevI02KrICDDCGX424E1j
````
Cuando nos genera un Success, nosotros podemos regenerar la consulta presionando la opción ``Start over`` y volver
a ejecutar el cuerpo anteriormente definido. Una vez con todo esto, debemos ahora intercambiar el Authorization Code por
el token que necesitamos, para ello, nos copiamos el Authorization Code y nos vamos a nuestro cliente (Postman en este caso)
y generamos el token, la petición se verá como este CURL:

````dockerfile
curl --location 'http://localhost:9776/authorization-server/oauth2/token' \
--header 'Content-Type: application/x-www-form-urlencoded' \
--header 'Authorization: ••••••' \
--header 'Cookie: JSESSIONID=3A2CD4C820FBAF90503A0051678BC45D' \
--data-urlencode 'grant_type=authorization_code' \
--data-urlencode 'client_id=client' \
--data-urlencode 'redirect_uri=https://oauthdebugger.com/debug' \
--data-urlencode 'code=IiE6lQzHu_E63KgF3CsqKm8LeCcY4P3XIPU0qvkoscJwxWgSxxqBLX7b_lyfmvMrB8SzUQ81HY4c4ekrKp2u4z-2BkmzUXe3gR8mbiDbHBso3DxFlC83Q7_F1bKIm018'
````
Petición: ``POST con body x-www-form-urlenconder``. Prestemos especial atención a los campos:
* grant_type=authorization_code
* client_id=client
* redirect_uri=https://oauthdebugger.com/debug
* code=IiE6lQzHu_E63KgF3CsqKm8LeCcY4P3XIPU0qvkoscJwxWgSxxqBLX7b_lyfmvMrB8SzUQ81HY4c4ekrKp2u4z-2BkmzUXe3gR8mbiDbHBso3DxFlC83Q7_F1bKIm018

``En el code enviamos el Authorization Code que se nos generó en el oauthdebugger``, en este punto es donde terminamos haciendo
el intercambio por un token, y el token viene siendo al final el access_token generado cuando realizamos todo el proceso
de OAuth2 correctamente. No olvidar enviar en el Auth el Basic Auth donde, como efectos de prueba, el username es 
``client-pamplona`` y el password es ``secret`` (Recordemos que secret es una palabra encriptada)

Con esto debemos obtener una respuesta JSON donde tenemos el access_token, refresh_token, scope, id_token, token_type y expire.
Para cerrar la sesión basta con ejecutar: http://localhost:9776/authorization-server/logout y confirmamos que si queremos cerrar
la sesión para eliminar las cookies y demás elementos internos que usa OAuth2 en su proceso.

# NOTAS ADICIONALES:

* La base de datos (Docker) debe estar levantada.
* Esta aplicación debe estar corriendo primero que la API principal para que haga match con la IP de Auth.
* Las entidades de Usuario deben estar sincronizadas en ambas aplicaciones.
* Estaremos trabajando con una UI de Thymeleaf para el tema de Login y Logout, aunque podríamos haberlo hecho
mediante End Points, pero para probar debemos usar las interfaces designadas.


